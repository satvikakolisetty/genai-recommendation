-- Create database and schema
CREATE DATABASE IF NOT EXISTS RECOMMENDATION_DB;
USE DATABASE RECOMMENDATION_DB;

CREATE SCHEMA IF NOT EXISTS PUBLIC;
USE SCHEMA PUBLIC;

-- Create warehouse with auto-scaling
CREATE WAREHOUSE IF NOT EXISTS RECOMMENDATION_WH
WITH
    WAREHOUSE_SIZE = 'X-SMALL'
    AUTO_SUSPEND = 300
    AUTO_RESUME = TRUE
    MIN_CLUSTER_COUNT = 1
    MAX_CLUSTER_COUNT = 3
    SCALING_POLICY = 'STANDARD';

-- Create base table for user interactions
CREATE OR REPLACE TABLE USER_INTERACTIONS (
    USER_ID STRING,
    ITEM_ID STRING,
    INTERACTION_TYPE STRING,
    EVENT_TIME TIMESTAMP_NTZ,
    PROCESSED_AT TIMESTAMP_NTZ,
    METADATA VARIANT,
    -- Partition by event time for efficient querying
    PARTITION BY (DATE_TRUNC('DAY', EVENT_TIME))
)
CLUSTER BY (USER_ID, ITEM_ID);

-- Create materialized view for user-item interactions
CREATE OR REPLACE MATERIALIZED VIEW USER_ITEM_INTERACTIONS_MV
AS
SELECT
    USER_ID,
    ITEM_ID,
    COUNT(*) as INTERACTION_COUNT,
    MAX(EVENT_TIME) as LAST_INTERACTION_TIME,
    ARRAY_AGG(DISTINCT INTERACTION_TYPE) as INTERACTION_TYPES,
    OBJECT_AGG(INTERACTION_TYPE, COUNT(*)) as INTERACTION_TYPE_COUNTS
FROM USER_INTERACTIONS
GROUP BY USER_ID, ITEM_ID;

-- Create materialized view for user preferences
CREATE OR REPLACE MATERIALIZED VIEW USER_PREFERENCES_MV
AS
SELECT
    USER_ID,
    OBJECT_AGG(ITEM_ID, INTERACTION_COUNT) as ITEM_PREFERENCES,
    SUM(INTERACTION_COUNT) as TOTAL_INTERACTIONS,
    COUNT(DISTINCT ITEM_ID) as UNIQUE_ITEMS
FROM USER_ITEM_INTERACTIONS_MV
GROUP BY USER_ID;

-- Create materialized view for item popularity
CREATE OR REPLACE MATERIALIZED VIEW ITEM_POPULARITY_MV
AS
SELECT
    ITEM_ID,
    COUNT(DISTINCT USER_ID) as UNIQUE_USERS,
    SUM(INTERACTION_COUNT) as TOTAL_INTERACTIONS,
    AVG(INTERACTION_COUNT) as AVG_INTERACTIONS_PER_USER
FROM USER_ITEM_INTERACTIONS_MV
GROUP BY ITEM_ID;

-- Create view for real-time recommendations
CREATE OR REPLACE VIEW RECOMMENDATIONS_V
AS
WITH USER_SIMILARITY AS (
    SELECT
        a.USER_ID as USER_ID,
        b.USER_ID as SIMILAR_USER_ID,
        COUNT(DISTINCT a.ITEM_ID) as COMMON_ITEMS,
        CORR(a.INTERACTION_COUNT, b.INTERACTION_COUNT) as SIMILARITY_SCORE
    FROM USER_ITEM_INTERACTIONS_MV a
    JOIN USER_ITEM_INTERACTIONS_MV b
        ON a.ITEM_ID = b.ITEM_ID
        AND a.USER_ID < b.USER_ID
    GROUP BY a.USER_ID, b.USER_ID
    HAVING COMMON_ITEMS >= 3
)
SELECT
    u.USER_ID,
    i.ITEM_ID,
    SUM(s.SIMILARITY_SCORE * i.INTERACTION_COUNT) as RECOMMENDATION_SCORE
FROM USER_SIMILARITY s
JOIN USER_ITEM_INTERACTIONS_MV i
    ON s.SIMILAR_USER_ID = i.USER_ID
JOIN USER_ITEM_INTERACTIONS_MV u
    ON s.USER_ID = u.USER_ID
    AND u.ITEM_ID != i.ITEM_ID
GROUP BY u.USER_ID, i.ITEM_ID
QUALIFY ROW_NUMBER() OVER (PARTITION BY u.USER_ID ORDER BY RECOMMENDATION_SCORE DESC) <= 10;

-- Create stored procedure for refreshing materialized views
CREATE OR REPLACE PROCEDURE REFRESH_MATERIALIZED_VIEWS()
RETURNS STRING
LANGUAGE JAVASCRIPT
AS
$$
    var views = [
        'USER_ITEM_INTERACTIONS_MV',
        'USER_PREFERENCES_MV',
        'ITEM_POPULARITY_MV'
    ];
    
    for (var i = 0; i < views.length; i++) {
        var view = views[i];
        var stmt = snowflake.createStatement({
            sqlText: `ALTER MATERIALIZED VIEW ${view} REFRESH`
        });
        stmt.execute();
    }
    
    return "Successfully refreshed all materialized views";
$$; 